# 右键菜单设计文档

## 1. 需求概述

实现类似Windows资源管理器的右键菜单功能，通过win32-api库读取注册表，提供三种不同场景下的右键菜单交互。

## 2. 功能场景

### 2.1 场景一：光标在选中的文件上

**触发条件：**
- 已选中单个文件
- 鼠标右键点击该文件区域

**菜单项：**
- 复制
- 剪切
- 粘贴
- 打开方式（二级菜单）

**功能说明：**
- 剪切：将选中文件移动到剪贴板
- 复制：将选中文件复制到剪贴板
- 重命名：重命名选中文件
- 打开方式：解析注册表，显示可用的打开程序列表

### 2.2 场景二：光标在复选的内容上

**触发条件：**
- 已选中多个文件（通过框选或Ctrl+点击）
- 鼠标右键点击任意已选中的文件区域

**菜单项：**
- 剪切
- 复制

**功能说明：**
- 复制：将所有选中文件复制到剪贴板
- 剪切：将所有选中文件移动到剪贴板

### 2.3 场景三：光标在空白区域

**触发条件：**
- 未选中任何文件
- 鼠标右键点击空白区域

**菜单项：**
- 粘贴
- 新建（自动展开子菜单）

**功能说明：**
- 粘贴：从剪贴板粘贴文件到当前目录
- 新建：解析注册表，显示可新建的文件类型列表
- 鼠标悬停在"新建"上时自动展开子菜单

## 3. 技术方案

### 3.1 技术栈

- **Electron**：桌面应用框架
- **win32-api**：读取Windows注册表
- **React**：前端UI框架
- **Ant Design**：UI组件库（Dropdown组件）

### 3.2 注册表路径

#### 3.2.1 打开方式注册表路径

```
HKEY_CLASSES_ROOT\*\shell\openwith\command
HKEY_CLASSES_ROOT\*\OpenWithList\*
HKEY_CLASSES_ROOT\*\OpenWithProgids
HKEY_CLASSES_ROOT\Applications\<应用名>\shell\open\command
```

#### 3.2.2 新建文件类型注册表路径

```
HKEY_CLASSES_ROOT\.<扩展名>\ShellNew
HKEY_CLASSES_ROOT\.<扩展名>\PerceivedType
HKEY_CLASSES_ROOT\<文件类型>\ShellNew
HKEY_CLASSES_ROOT\Directory\Background\shell\New
```

### 3.3 注册表解析逻辑

#### 3.3.1 解析打开方式

1. 读取文件扩展名对应的ProgID
2. 查找关联的应用程序
3. 读取应用程序的命令行、图标路径
4. 构建菜单项数据结构

```typescript
interface OpenWithApp {
  name: string;
  command: string;
  iconPath: string;
  displayName: string;
}
```

#### 3.3.2 解析新建文件类型

1. 枚举常见文件扩展名
2. 检查是否存在ShellNew子键
3. 读取文件类型名称和图标
4. 构建菜单项数据结构

```typescript
interface NewFileType {
  extension: string;
  name: string;
  iconPath: string;
  templatePath?: string;
}
```

## 4. UI设计

### 4.1 菜单组件结构

```
ContextMenu
├── MenuItem (复制)
├── MenuItem (剪切)
├── MenuItem (粘贴)
├── SubMenu (打开方式)
│   ├── MenuItem (应用1)
│   ├── MenuItem (应用2)
│   └── ...
└── SubMenu (新建)
    ├── MenuItem (文件夹)
    ├── MenuItem (文本文档)
    └── ...
```

### 4.2 菜单样式

- 使用Ant Design的Dropdown组件
- 菜单项显示图标和名称
- 子菜单使用箭头指示
- 支持快捷键显示
- 鼠标悬停高亮

### 4.3 交互行为

- 右键点击触发菜单
- 点击菜单项执行操作
- ESC键关闭菜单
- 点击其他区域关闭菜单
- 新建子菜单自动展开（鼠标悬停）

## 5. 数据结构

### 5.1 菜单项数据结构

```typescript
interface ContextMenuItem {
  key: string;
  label: string;
  icon?: React.ReactNode;
  disabled?: boolean;
  shortcut?: string;
  onClick?: () => void;
  children?: ContextMenuItem[];
}
```

### 5.2 菜单上下文

```typescript
interface MenuContext {
  targetFile?: FileEntry;
  selectedFiles: FileEntry[];
  clickPosition: { x: number; y: number };
  menuType: 'single-file' | 'multi-file' | 'blank';
}
```

## 6. 实现步骤

### 6.1 Electron主进程

1. **安装依赖**
   ```bash
   npm install win32-api
   ```

2. **创建注册表读取模块**
   - 实现读取注册表键值
   - 实现枚举注册表子键
   - 实现解析应用程序信息

3. **创建IPC通信接口**
   ```typescript
   // preload.js
     contextBridge.exposeInMainWorld('api', {
     getOpenWithApps: (filePath: string) => Promise<OpenWithApp[]>,
     getNewFileTypes: () => Promise<NewFileType[]>,
     copyFiles: (paths: string[]) => Promise<void>,
     cutFiles: (paths: string[]) => Promise<void>,
     pasteFiles: (destPath: string) => Promise<void>,
     createNewFile: (type: string, name: string, destPath: string) => Promise<string>
   });
   ```

### 6.2 React渲染进程

1. **创建ContextMenu组件**
   ```typescript
   const ContextMenu: React.FC<ContextMenuProps> = ({
     visible,
     position,
     context,
     onClose
   }) => {
     const menuItems = useMemo(() => buildMenu(context), [context]);
     
     return (
       <Dropdown
         menu={{ items: menuItems }}
         open={visible}
         onOpenChange={onClose}
         trigger={['contextMenu']}
       >
         <div style={{ position: 'fixed', left: position.x, top: position.y }} />
       </Dropdown>
     );
   };
   ```

2. **实现菜单构建逻辑**
   ```typescript
   const buildMenu = (context: MenuContext): ContextMenuItem[] => {
     switch (context.menuType) {
       case 'single-file':
         return buildSingleFileMenu(context);
       case 'multi-file':
         return buildMultiFileMenu(context);
       case 'blank':
         return buildBlankMenu(context);
     }
   };
   ```

3. **集成到文件显示区域**
   - 在file-display区域添加onContextMenu事件
   - 根据点击位置判断菜单类型
   - 显示ContextMenu组件

### 6.3 注册表解析实现

```typescript
// 读取打开方式
async function getOpenWithApps(filePath: string): Promise<OpenWithApp[]> {
  const ext = path.extname(filePath);
  const apps: OpenWithApp[] = [];
  
  // 读取关联的应用程序
  const assocApps = await readRegistry(`HKEY_CLASSES_ROOT\${ext}\OpenWithList`);
  // ... 解析逻辑
  
  return apps;
}

// 读取新建文件类型
async function getNewFileTypes(): Promise<NewFileType[]> {
  const types: NewFileType[] = [];
  const commonExts = ['.txt', '.docx', '.xlsx', '.pptx', '.zip'];
  
  for (const ext of commonExts) {
    const hasShellNew = await checkRegistryKey(
      `HKEY_CLASSES_ROOT\${ext}\ShellNew`
    );
    if (hasShellNew) {
      types.push(await parseFileType(ext));
    }
  }
  
  return types;
}
```

## 7. 注意事项

### 7.1 性能优化

- 缓存注册表查询结果
- 异步加载子菜单内容
- 防抖处理右键事件

### 7.2 错误处理

- 注册表读取失败时的降级方案
- 文件操作失败时的错误提示
- 权限不足时的友好提示

### 7.3 兼容性

- 支持Windows 10及以上版本
- 处理不同Windows版本的注册表差异
- 支持中文文件名和路径

### 7.4 安全性

- 验证注册表读取的路径
- 防止命令注入攻击
- 限制可执行的程序范围


## 10. 参考资料

- [Windows Registry Reference](https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry)
- [Electron IPC Documentation](https://www.electronjs.org/docs/latest/tutorial/ipc)
- [Ant Design Dropdown](https://ant.design/components/dropdown)
- [File Association in Windows](https://docs.microsoft.com/en-us/windows/win32/shell/fa-file-types)