主进程数据库并发冲突解决方案（不含性能优化）

**目标与范围**
解决主进程中与数据库一致性相关的并发冲突问题，优先保证数据正确与流程可恢复。此文档不讨论性能优化。

**关键决策**
1. 文件系统变更的数据库写入以 watcher 为唯一入口，内部操作不再直接调用 `watcherManager.handleAdd/Delete`。
2. 内部操作通过“操作记录”与 watcher 事件进行关联，动态清理标记并提供超时补救。
3. 所有涉及多条数据库操作的关键流程必须使用事务，失败可回滚并有补救策略。
4. 同一路径的并发请求必须串行化，跨路径的无关联操作允许并行。

**问题 1：Watcher 与手动 DB 更新重复触发**
现状问题
内部操作既调用 `watcherManager.handleAdd/Delete`，watcher 又会产生 `add/unlink`，导致重复写库与重复事件，偶发顺序错乱。

解决方案
采用“watcher 统一写入 + 操作记录关联”的策略。

实施要点
1. 操作记录结构包含 `opId`、`type`、`paths`、`startedAt`、`timeoutMs`、`metaSnapshot`。
2. 内部操作开始时登记记录，不再手动调用 `watcherManager.handleAdd/Delete`。
3. watcher 收到事件时匹配操作记录并标记完成，同时正常写库并发出 `fs-change`。
4. 超时保护在 `timeoutMs` 触发，执行补救同步并提示用户。
5. UI 进度使用现有 `operationStatus` 事件维持，不依赖手动 `fs-change`。

补救同步策略
1. 对超时路径执行一次 `fs.stat` 判断存在性。
2. 存在则执行最小化 upsert，仅更新 `type` 并保留自定义元数据。
3. 不存在则删除数据库记录。

**问题 2：读-改-写竞争导致“旧值覆盖新值”**
现状问题
`listDirectory` 与 `move/rename` 会读取元数据再写回，可能覆盖并发写入的 `level_tag/custom_time`。

解决方案
只更新必要字段，避免回写自定义元数据。

实施要点
1. `listDirectory` 仅插入缺失行与更新 `type`，不写回 `level_tag/custom_time`。
2. `move/rename` 的元数据迁移不再“读后完整写回”，改为队列化后使用“元数据快照 + watcher 写入”。
3. 元数据快照只用于同一次移动/重命名的写入，且在路径队列串行化下保证一致性。

**问题 3：多步业务流程非原子**
现状问题
`move/rename/delete-by-level` 涉及多条数据库操作与文件系统操作，失败会留下半更新状态。

解决方案
引入数据库事务，并提供失败补救。

实施要点
1. `DatabaseManager` 增加 `beginTransaction/commitTransaction/rollbackTransaction`。
2. 关键流程的数据库操作都包裹在事务内。
3. 文件系统操作失败时回滚数据库操作，并在必要时提示用户进行重试或重扫。
4. 事务使用 `BEGIN IMMEDIATE`，避免并发写入的交错。

**问题 4：文件系统并发变化导致 DB/视图异常**
现状问题
文件在扫描或读取过程中被删除/占用会导致整体失败。

解决方案
统一错误处理策略，避免单文件异常拖垮整体操作。

实施要点
1. 对 `ENOENT/EPERM/EACCES/EBUSY` 等常见错误显示友好提示。
2. 对单文件失败采取“跳过 + 记录 + 允许重试”的策略。
3. 未知错误直接显示原始错误信息，便于定位。

**问题 5：同一路径的多请求并发无隔离**
现状问题
同一路径的并发请求顺序不确定，可能出现 UI 与后端处理顺序不一致。

解决方案
引入“路径级任务队列”，同一路径或父子路径串行，不相关路径并行。

实施要点
1. 每个任务计算“路径关联键”，同键串行，不同键并行。
2. 对跨路径操作（move/copy）同时锁定源和目标的关联键。
3. 渲染进程的操作顺序通过队列保证，与后端处理顺序一致。

**落地清单**
1. 移除内部操作中对 `watcherManager.handleAdd/Delete` 的直接调用。
2. 新增操作记录与超时补救逻辑。
3. 调整 `listDirectory` 的 upsert 行为，避免回写自定义元数据。
4. 引入事务与路径级队列，并改造 `move/rename/delete-by-level` 的执行流程。
5. 统一错误处理与提示逻辑。
